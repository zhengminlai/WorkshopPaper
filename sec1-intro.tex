\section{Introduction}
\label{sec:intro}
In this paper, we study subgraph matching, which is one of the most fundamental problem about graph analysis. Given a query graph $q$ and a data graph $G$, subgraph matching is defined to find all subgraph instances of $G$ that are isomorphic to $p$. Subgraph matching is widely used in numerous domains. For example, it is used to illustrate the evolution process of social networks\cite{kairam2012life}, identify terrorist cells in activity networks\cite{cook2006mining}, and discover certain features of biological or chemical networks\cite{Cannataro2010}. Subgraph matching is also a basic operation of the query language in graph databases such as Neo4j\cite{neo4j} and Gremlin\cite{gremlin}.

\stitle{Existing Solutions.} Unfortunately, the computation of subgraph matching is proven to be NP-complete\cite{Shamir97}. In recent years, a lot of effort has been contributed to improving the efficiency of subgraph matching. The naive approach is to perform brute-force search over all subgraphs of data graph $G$. Ullman's backtracking algorithm\cite{Ullmann1976} studies on searching order, pruning rules and neighbourhood indexes to find all subgraphs. \vftwo \cite{cordella2004sub} and \quicksi \cite{Shang2008} focus on designing better indexes or pruning rules to further improve the efficiency. However, these works are all sequential algorithms that can not handle large scale graphs in a single machine. Discovering the poor efficiency and scalability of sequential algorithms, researchers seek to develop subgraph matching algorithms in the distributed context.
\psgl \cite{Shao2014}, \starjoin \cite{Sun2012}, \ttjoin \cite{Lai2015} and \cliquejoin \cite{Lai2016} perform subgraph matching by joining the sub-structure of the query graph, where the basic sub-sturcture is called \textit{join unit}. Those four algorithms mainly differ in the join order and join unit. \psgl is a variant of \starjoin. \ttjoin is instance optimal to \starjoin. \cliquejoin extends \starjoin, where \cliquejoin can use both star and clique as join unit and its optimal join plan is expressed in the form of a bushy tree \cite{tree}. Instead of joining subgraphs, \bigjoin \cite{Ammar2018} and \crystaljoin \cite{qiao2017subgraph} adopt expanding vertices strategy in each round. Another algorithm \multiwayjoin \cite{AfratiFU13} is to divide the search space evenly into workers, then each worker can finish the subgraph computation locally. 

\stitle{Motivation.} \cliquejoin has been proven to be the most efficient algorithm in the category of joining subgraphs\cite{Lai2016}. However, \cliquejoin has two limitations. First, it is implemented on Map-Reduce, where frequent I/O operations will occur in each round. Therefore, the performacne of the algorithm can be greatly affected. Second, while most of the graphs in real life are labelled graphs, it doesn't propose a cost evaluation strategy for them. Hence it can not generate optimal join plan for labelled graphs.

\stitle{Contributions.} In this paper, we propose \gencliqjoin by extending and improving the state-of-the-art algorithm \cliquejoin as follows:

\sstitle{(1) Generalizing \cliquejoin to perform subgraph matching on labelled graphs.} We refine the cost evaluation function for \cliquejoin that can generate optimal join plan for labelled graphs. By doing this, we can easily extend \cliquejoin to do labelled subgraph matching. In consequence, the generality of \cliquejoin will be significantly improved.

\sstitle{(2) Reimplementing \cliquejoin on \timely dataflow system}\cite{Murray2013}. We reimplement \cliquejoin on \timely dataflow system, a high performance distributed framework, to avoid frequent I/O operations in Map-Reduce. Hence the performance of \cliquejoin can be greatly improved.

\sstitle{(3) In-depth performance studies on large datasets.} We perform large scale and in-depth experiments on both unlabelled and labelled graphs. Comparing with original version on Map-Reduce, our implementation speeds up \cliquejoin by 2 times to 10 times in general. The experimental results also show that \gencliqjoin has excellent performance and scalability doing labelled subgraph matching, even if the graph is of billion scale.

\stitle{Organization.} The rest of the paper is organized as follows. Section \ref{sec:prelim} introduces the definition of subgraph matching and preliminary knowledge. Section \ref{sec:opt} introduces \gencliqjoin, which extends \cliquejoin to do labelled subgraph matching, and its implementation details on \timely dataflow system. Section \ref{sec:exp} illustrates the experimental results of doing subgraph matching on both unlabelled and labelled large graphs. Section \ref{sec:rel} shows related works, and section \ref{sec:conclusion} concludes the paper.