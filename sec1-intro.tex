\section{Introduction}
\label{sec:intro}
Given a query graph $q$ and a data graph $G$, subgraph matching is defined to find all subgraph instances of $G$ that are isomorphic to $q$. Subgraph matching is one of the most fundamental problems in graph analytics, and is widely used in many domains. For example, it is used to illustrate the evolution process of social networks\cite{kairam2012life}, to identify terrorist cells in activity networks\cite{cook2006mining}, and to discover certain features of biological or chemical networks\cite{Cannataro2010}. Subgraph matching is also a basic operation of graph databases such as Neo4j\cite{neo4j} and graph languages such as Gremlin\cite{gremlin}.

\stitle{Existing Solutions.} Despite its usefulness, subgraph matching is computationally intensive because it depends on the NP-complete operation, \textit{subgraph isomorphism}\cite{Shamir97}. In recent years, people have devoted a lot of efforts to improving the efficiency of subgraph matching. The first practical algorithm for computing subgraph isomorphism problem was proposed by Ullmann \cite{Ullmann1976}. Subsequent algorithms such as VF2 \cite{cordella2004sub}, QuickSI \cite{Shang2008}, TurboISO \cite{turbo-iso} and CFL\cite{bi-fei} are developed to further improve the performance by designing better pruning rules and/or indexing structures. However, these works are all sequential algorithms that can hardly handle large-scale graphs in real life. While finding out the natural binding between subgraph matching and relational joins, people turned to develop both efficient and scalable distributed algorithms for subgraph matching by processing join operations. \starjoin \cite{star-join} is the first algorithm to tackle subgraph matching via join in the distributed context. The idea is to decompose the query graph into a set of stars (star is a tree of depth 1), computing matches of each star and then joining them to form the final result. This idea, called \textit{decomposition-and-join}, inspires a series of following-up works including \psgl \cite{Shao2014}, \ttjoin \cite{Lai2015} and \cliquejoin \cite{Lai2016}. \cliquejoin develops the state-of-the-art solution using the \textit{decomposition-and-join} scheme, which decomposes the query into both stars and cliques (a complete graph), and then perform the \textbf{optimal} bushy join. There are some alternative schemes other than decomposition-and-join. Ammar et al. proposed \bigjoin that solves the join using a variance of worst-case optimal join algorithm \cite{generic-join}. Afrati et al. proposed \multiwayjoin \cite{AfratiFU13}  that attempts to divide the search space evenly into the configured workers in the cluster, then each worker can process its own computation locally. 

\stitle{Motivations and challenges.} Although \cliquejoin is optimal following the decomposition-and-join scheme \cite{Lai2016}, it has two limitations. First, it is designed and implemented on MapReduce, which requires the data to be written to the disk at the end of certain join round and read back from disk for the consecutive round. This can cause severe bottleneck while processing multi-round I/O-intensive tasks such as subgraph matching. Second, while most of the graphs in real life are labelled graphs, \cliquejoin only considers unlabelled matching, and may not compute optimal join plan for labelled matching without considering the labels' statistics.

In this paper, we propose \gencliqjoin to resolve the issues of \cliquejoin. To avoid costly I/O operations in MapReduce, we implement the algorithm on the \timely dataflow system \cite{Murray2013}. \timely is a more general distributed engine than MapReduce. Instead of constraining the data to be written to the disk at the end of a computing round, \timely allows the user to program the desired way of maintaining the output data (internal memory by default). To extend \cliquejoin's usability in labelled matching, we refine the cost evaluation function for \cliquejoin by taking the labels' frequencies into consideration in order to compute optimal join plans for labelled graphs.

The implementation of \gencliqjoin is non-trivial. Firstly, we target a generic implementation that can solve any query. Note that the original implementation\footnote{\url{https://github.com/longbinlai/SubgEnumFramework}} of \cliquejoin is hardcoded for each query, which largely eases the implementation. It is challenging to translate the join plan of an ambiguous query into \timely-executable dataflow. Secondly, the cost function for unlabelled matching in \cliquejoin is already complicated, while we still need to inject the labels' statistics into the cost function for better estimations of the labelled matching.

There are some alternatives of optimizing distributed subgraph matching.

\begin{enumerate}
    \item Alternative computing engines. There are alternative engines such as Spark \cite{spark} and Flink \cite{flink} to replace MapReduce. We tend to use \timely here due to (1) it is more flexible to program; (2) it draws lower system cost compared to the other popular engines \cite{McSherry2015}.
    \item Alternative algorithms. There are at least two alternative algorithms to study, namely \bigjoin and \multiwayjoin. However, they do not draw our attention due to the following reasons. \bigjoin does not invent a new join scheme, but simply adopts different algorithm to process the join. We can also implement the join scheme of \cliquejoin using \bigjoin's join algorithm, which is also suggested by the authors of \bigjoin \cite{Ammar2018}. Therefore, it is more fundamental to study \cliquejoin. Although \multiwayjoin does follow a different join scheme, researchers have already observed that it can end up with carrying the whole graph in each worker and thus can scale out poorly \cite{Lai2016, Ammar2018}.   
\end{enumerate}

\stitle{Contributions.} In this paper, we propose \gencliqjoin by extending and improving the state-of-the-art algorithm \cliquejoin. We make the following contributions.

\sstitle{(1) Reimplementing \cliquejoin on \timely dataflow system}. We reimplement \cliquejoin for any generic query on \timely dataflow system, a high throughput distributed data engine, to avoid the I/O issue of MapReduce. 

\sstitle{(2) Generalizing \cliquejoin to do labelled subgraph matching.} We refine the cost evaluation function for \cliquejoin that can generate optimal join plans for labelled graphs. As most of real graphs are labelled, we greatly expand the usability of \cliquejoin in practice.

\sstitle{(3) In-depth performance studies on large datasets.} We perform in-depth experiments on both unlabelled and labelled graphs. For unlabelled experiment, we observe that our implementation can speed up \cliquejoin by up to 10 times. For labelled experiment, the results demonstrate that \gencliqjoin achieves good performance and scalability, and can process data graph of billions of edges.

\stitle{Organization.} The rest of the paper is organized as follows. Section \ref{sec:prelim} introduces the definition of subgraph matching and preliminary knowledge. Section \ref{sec:opt} introduces \gencliqjoin, which extends \cliquejoin to do labelled subgraph matching, and its implementation details on \timely dataflow system. Section \ref{sec:exp} illustrates the experimental results of doing subgraph matching on both unlabelled and labelled graphs. Section \ref{sec:rel} shows related works, and section \ref{sec:conclusion} concludes the paper.