\section{Realted Work}
\label{sec:rel}

\stitle{Subgraph Enumeration.} The first practical algorithm for subgraph enumeration was proposed by Ullmann in \cite{Ullmann1976}. It is a backtracking algorithm which finds solutions by increasing partial solutions or abandoning them when it determines they can not reach to final results. Most of existing algorithms for subgraph enumeration follow Ullmann's backtracking approach. They exploit different join orders, pruning rules, and auxiliary information to narrow the search space, thereby enhance the performance. In particular, \vftwo \cite{cordella2004sub} and \quicksi \cite{Shang2008} use \textit{connected matching order} that generates the matching order by selecting a vertex connected to one of the already selected vertices rather than a random selection to prune false positive candidates as early as possible. GraphQL \cite{graph-ql} and SPath \cite{spath} focus on reducing the candidates of query vertices by exploiting neighborhood-based filtering. TurboISO \cite{turbo-iso} and the boost technique in \cite{subgraph-boost} propose to merge vertices with same labels and the same neighbours in $q$ and $G$ respectively to reduce the matching complexity. \cite{comparison} provides an in-depth comparison of above mentioned subgraph isomorphism algorithms. A more recent work in \cite{bi-fei} uses a data structure called \textit{compact path index} (CPI) to store the potential embeddings of a spanning tree of the query graph to improve both time and space efficiency. Algorithms of subgraph enumeration mainly focuses on answering a single query, \cite{multi-query} studies the problem of \textit{multiple query optimization} (MQO) for subgraph enumeration. The details of distributed subgraph enumeration algorithms can be found in Section \ref{sec:intro}.

\stitle{Subgraph Containment Search.} Let $\mathcal{D}=\{g_1,g_2,\dots,g_n\}$ be a graph database that has $n$ graphs, the problem of subgraph containment search over a graph database is to identify if the graphs in $\mathcal{D}$ contain the given query graph $q$. To speed up the search, many graph-feature based approaches have been proposed, performing graph indexing and adopting a filter-and-verification framework. As a result of such approach, false positives are removed by a pruning strategy before subgraph isomorphism algorithm is performed on each of the remaining candidates to obtain the final results. Existing works includes \textit{frequent subgraph mining based approaches} (e.g., gIndex \cite{gindex}, Tree+$\Delta$ \cite{tree+}, and FG-Index \cite{fg-index}) and \textit{exhaustive enumeration based approaches} (e.g., gCode \cite{gcode}, CT-Index \cite{ct-index}, GraphGrep \cite{graph-grep}, GraphGrepSX \cite{graph-grep-sx}, Closure-tree \cite{closure-tree}, and Grapes \cite{grapes}). In approximate graph containment search, TALE \cite{tale} was proposed.